// ABOUT

// Function for proving membership of a leaf in a Merkle Tree of height h = 4.
//
//            level h:             root
//                              /       \
//                                 ...
//              ...
//                       /    \    ...   /   \
//            level 1:
//                     /  \  /  \  ... /  \  /  \
//  leaves at level 0:


// IMPORTS

import "utils/pack/unpack128.code" as unpack128

import "../hashes/mimc/mimc-hash-2.zok" as hash2 // can swap with other hash function
import "./order-left-and-right.zok" as orderLeftAndRight


// MAIN

// EXAMPLE WITNESS: 1234 2345 3456 4567 1235678 3
// Note: in this example witness, the MSACommitmentSiblingPathToMSARoot values 1234 2345 3456 4567 are dummy values of nodes in the Merkle Tree, which are siblings to the MSA commitment's path. In reality these will be hash values.

// @param {field[4]} witness - the values of the sibling nodes of the path from the leaf to the root
// @param {field} leafValue - the value of the leaf. We aim to prove this leaf is in the tree.
// @param {field} leafIndex - the index of the leaf within the leaves (indexing starts from zero). Note: the binary decomposition of a leaf's index gives us the 'left-rightness' of that leaf's path up the Merkle Tree.
// @returns {field} root - the root of the merkle tree

def main(private field[4] witness, private field leafValue, private field leafIndex) -> (field):

  // Hash up the Merkle Tree to the root:

  field[128] leafIndexBits = unpack128(leafIndex)
  field nodeValue = leafValue
  field[2] preimage = [0, 0]

  for field i in 0..4 do
    field j = 3 - i // iterator for the witness
    field k = 127 - i // iterator for the leafIndexBits
    preimage = orderLeftAndRight(leafIndexBits[k], nodeValue, witness[j])
    nodeValue = hash2(preimage)
  endfor

  field root = nodeValue

  return root
